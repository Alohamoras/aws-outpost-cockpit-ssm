{
    "schemaVersion": "2.2",
    "description": "AWS Outpost Storage Configuration - RAID5 setup for data drives and root OS volume extension",
    "parameters": {
        "snsTopicArn": {
            "type": "String",
            "description": "SNS Topic ARN for notifications",
            "default": ""
        },
        "instanceId": {
            "type": "String",
            "description": "Instance ID for notifications",
            "default": ""
        }
    },
    "mainSteps": [
        {
            "action": "aws:runShellScript",
            "name": "configureStorage",
            "inputs": {
                "timeoutSeconds": "3600",
                "runCommand": [
                    "#!/bin/bash",
                    "",
                    "# Storage Configuration for AWS Outpost Cockpit",
                    "# Configures RAID5 for data drives and extends root OS volume",
                    "",
                    "set -e",
                    "",
                    "# Parameters from SSM",
                    "SNS_TOPIC_ARN='{{ snsTopicArn }}'",
                    "INSTANCE_ID='{{ instanceId }}'",
                    "REGION=$(curl -s http://169.254.169.254/latest/meta-data/placement/region)",
                    "",
                    "# Logging setup",
                    "LOG_FILE=\"/var/log/ssm-storage-config.log\"",
                    "exec > >(tee -a \"$LOG_FILE\") 2>&1",
                    "",
                    "# Color output",
                    "RED='\\033[0;31m'",
                    "GREEN='\\033[0;32m'",
                    "YELLOW='\\033[1;33m'",
                    "BLUE='\\033[0;34m'",
                    "NC='\\033[0m'",
                    "",
                    "log_info() { echo -e \"${BLUE}[INFO]${NC} $*\"; }",
                    "log_success() { echo -e \"${GREEN}[SUCCESS]${NC} $*\"; }",
                    "log_warning() { echo -e \"${YELLOW}[WARNING]${NC} $*\"; }",
                    "log_error() { echo -e \"${RED}[ERROR]${NC} $*\"; }",
                    "",
                    "# SNS notification function",
                    "send_notification() {",
                    "    local message=\"$1\"",
                    "    local subject=\"Storage Config - Instance $INSTANCE_ID\"",
                    "    if [[ -n \"$SNS_TOPIC_ARN\" ]]; then",
                    "        aws sns publish \\",
                    "            --region \"$REGION\" \\",
                    "            --topic-arn \"$SNS_TOPIC_ARN\" \\",
                    "            --subject \"$subject\" \\",
                    "            --message \"$message\" >/dev/null 2>&1 || true",
                    "    fi",
                    "}",
                    "",
                    "echo \"=== AWS OUTPOST STORAGE CONFIGURATION (RAID5 + Root Extension) ===\"",
                    "echo \"Started at: $(date)\"",
                    "echo \"Log file: $LOG_FILE\"",
                    "",
                    "send_notification \"Starting storage configuration: RAID5 for data drives and root OS extension\"",
                    "",
                    "# Check prerequisites",
                    "log_info \"Installing required tools...\"",
                    "if ! dnf install -y lvm2 parted xfsprogs mdadm bc; then",
                    "    log_error \"Failed to install required tools\"",
                    "    send_notification \"ERROR: Failed to install storage tools\"",
                    "    exit 1",
                    "fi",
                    "",
                    "# Function to detect boot drive",
                    "detect_boot_drive() {",
                    "    log_info \"Detecting boot drive...\"",
                    "    local root_device",
                    "    root_device=$(findmnt -n -o SOURCE / | head -1)",
                    "    ",
                    "    if [[ -z \"$root_device\" ]]; then",
                    "        log_error \"Could not determine root filesystem device\"",
                    "        return 1",
                    "    fi",
                    "    ",
                    "    log_info \"Root filesystem is on: $root_device\"",
                    "    ",
                    "    # Handle LVM root filesystem",
                    "    if [[ \"$root_device\" =~ /dev/mapper/ ]]; then",
                    "        log_info \"LVM root detected, finding underlying physical device...\"",
                    "        local vg_name",
                    "        if [[ \"$root_device\" =~ /dev/mapper/([^-]+)- ]]; then",
                    "            vg_name=\"${BASH_REMATCH[1]}\"",
                    "        else",
                    "            log_error \"Could not extract VG name from: $root_device\"",
                    "            return 1",
                    "        fi",
                    "        ",
                    "        local pv_devices",
                    "        mapfile -t pv_devices < <(pvdisplay -c | grep \":${vg_name}:\" | cut -d: -f1 | tr -d ' ')",
                    "        ",
                    "        if [[ ${#pv_devices[@]} -eq 0 ]]; then",
                    "            log_error \"No physical volumes found for VG: $vg_name\"",
                    "            return 1",
                    "        fi",
                    "        ",
                    "        local first_pv=\"${pv_devices[0]}\"",
                    "        first_pv=$(echo \"$first_pv\" | tr -d ' ')",
                    "        log_info \"Found PV: $first_pv\"",
                    "        ",
                    "        if [[ \"$first_pv\" =~ /dev/nvme[0-9]+n[0-9]+p[0-9]+ ]]; then",
                    "            BOOT_DRIVE=\"${first_pv%p*}\"",
                    "        elif [[ \"$first_pv\" =~ /dev/(sd[a-z]|xvd[a-z])[0-9]+ ]]; then",
                    "            BOOT_DRIVE=\"${first_pv%[0-9]*}\"",
                    "        else",
                    "            log_error \"Unknown PV device type: $first_pv\"",
                    "            return 1",
                    "        fi",
                    "    elif [[ \"$root_device\" =~ /dev/nvme[0-9]+n[0-9]+p[0-9]+ ]]; then",
                    "        BOOT_DRIVE=\"${root_device%p*}\"",
                    "    elif [[ \"$root_device\" =~ /dev/(sd[a-z]|xvd[a-z])[0-9]+ ]]; then",
                    "        BOOT_DRIVE=\"${root_device%[0-9]*}\"",
                    "    else",
                    "        log_error \"Unknown root device type: $root_device\"",
                    "        return 1",
                    "    fi",
                    "    ",
                    "    if [[ ! -b \"$BOOT_DRIVE\" ]]; then",
                    "        log_error \"Boot drive $BOOT_DRIVE is not a valid block device\"",
                    "        return 1",
                    "    fi",
                    "    ",
                    "    log_success \"Boot drive detected: $BOOT_DRIVE\"",
                    "    return 0",
                    "}",
                    "",
                    "# Function to extend boot drive",
                    "extend_boot_drive() {",
                    "    log_info \"Extending boot drive to use all available space...\"",
                    "    ",
                    "    if [[ -z \"$BOOT_DRIVE\" ]]; then",
                    "        log_warning \"Boot drive not detected, skipping extension\"",
                    "        return 0",
                    "    fi",
                    "    ",
                    "    if [[ ! -b \"$BOOT_DRIVE\" ]]; then",
                    "        log_warning \"Boot drive $BOOT_DRIVE not accessible, skipping extension\"",
                    "        return 0",
                    "    fi",
                    "    ",
                    "    # Check for free space",
                    "    local free_space_info",
                    "    log_info \"Checking for free space on boot drive...\"",
                    "    if ! free_space_info=$(timeout 30s parted \"$BOOT_DRIVE\" print free 2>/dev/null | grep \"Free Space\" | tail -1); then",
                    "        log_warning \"Could not check free space, skipping boot drive extension\"",
                    "        return 0",
                    "    fi",
                    "    ",
                    "    if [[ -z \"$free_space_info\" ]]; then",
                    "        log_info \"No free space found on boot drive\"",
                    "        return 0",
                    "    fi",
                    "    ",
                    "    # Extract free space size",
                    "    local free_space_raw",
                    "    free_space_raw=$(echo \"$free_space_info\" | awk '{print $3}')",
                    "    local free_space_gb",
                    "    ",
                    "    if [[ \"$free_space_raw\" =~ ([0-9.]+)GB ]]; then",
                    "        free_space_gb=${BASH_REMATCH[1]%.*}",
                    "    elif [[ \"$free_space_raw\" =~ ([0-9.]+)TB ]]; then",
                    "        free_space_gb=$((${BASH_REMATCH[1]%.*} * 1000))",
                    "    else",
                    "        log_info \"Free space too small or unknown unit: $free_space_raw\"",
                    "        return 0",
                    "    fi",
                    "    ",
                    "    # Proceed if we have significant free space (>10GB)",
                    "    if [[ -n \"$free_space_gb\" ]] && (( free_space_gb > 10 )); then",
                    "        log_info \"Found ${free_space_gb}GB free space, extending rocky VG...\"",
                    "        ",
                    "        # Get partition information",
                    "        local last_part_num",
                    "        last_part_num=$(parted \"$BOOT_DRIVE\" print | grep -E \"^ *[0-9]\" | tail -1 | awk '{print $1}')",
                    "        local next_part_num=$((last_part_num + 1))",
                    "        local last_part_end",
                    "        last_part_end=$(parted \"$BOOT_DRIVE\" print | grep -E \"^ *${last_part_num}\" | awk '{print $3}')",
                    "        ",
                    "        if [[ -n \"$last_part_end\" ]]; then",
                    "            log_info \"Creating partition ${next_part_num} from ${last_part_end} to 100%\"",
                    "            if parted \"$BOOT_DRIVE\" mkpart primary \"${last_part_end}\" 100% && \\",
                    "               parted \"$BOOT_DRIVE\" set \"$next_part_num\" lvm on; then",
                    "                ",
                    "                sleep 5",
                    "                partprobe \"$BOOT_DRIVE\"",
                    "                sleep 3",
                    "                ",
                    "                # Determine new partition name",
                    "                local new_partition",
                    "                if [[ \"$BOOT_DRIVE\" =~ nvme ]]; then",
                    "                    new_partition=\"${BOOT_DRIVE}p${next_part_num}\"",
                    "                else",
                    "                    new_partition=\"${BOOT_DRIVE}${next_part_num}\"",
                    "                fi",
                    "                ",
                    "                # Wait for partition to appear",
                    "                local wait_count=0",
                    "                while [[ ! -e \"$new_partition\" ]] && [[ $wait_count -lt 10 ]]; do",
                    "                    sleep 2",
                    "                    ((wait_count++))",
                    "                done",
                    "                ",
                    "                if [[ -e \"$new_partition\" ]]; then",
                    "                    if pvcreate \"$new_partition\" && vgextend rocky \"$new_partition\"; then",
                    "                        log_success \"Successfully extended rocky VG with ${free_space_gb}GB\"",
                    "                        send_notification \"Successfully extended root OS volume with ${free_space_gb}GB\"",
                    "                    else",
                    "                        log_error \"Failed to extend rocky VG\"",
                    "                    fi",
                    "                else",
                    "                    log_error \"New partition $new_partition did not appear\"",
                    "                fi",
                    "            else",
                    "                log_error \"Failed to create new partition\"",
                    "            fi",
                    "        else",
                    "            log_error \"Could not determine last partition end position\"",
                    "        fi",
                    "    else",
                    "        log_info \"Free space (${free_space_gb}GB) too small to extend\"",
                    "    fi",
                    "}",
                    "",
                    "# Function to detect unused data drives (non-root drives)",
                    "detect_unused_drives() {",
                    "    log_info \"Detecting unused data drives for RAID5...\"",
                    "    ",
                    "    # Get all block devices",
                    "    local all_drives",
                    "    mapfile -t all_drives < <(lsblk -dnp -o NAME,TYPE | grep 'disk$' | awk '{print $1}' | sort)",
                    "    ",
                    "    UNUSED_DRIVES=()",
                    "    log_info \"Examining ${#all_drives[@]} block devices...\"",
                    "    ",
                    "    for drive in \"${all_drives[@]}\"; do",
                    "        log_info \"Checking drive: $drive\"",
                    "        ",
                    "        # Skip the boot drive",
                    "        if [[ \"$drive\" == \"$BOOT_DRIVE\" ]]; then",
                    "            log_info \"  Skipping boot drive: $drive\"",
                    "            continue",
                    "        fi",
                    "        ",
                    "        # Check if drive is accessible",
                    "        if [[ ! -b \"$drive\" ]]; then",
                    "            log_warning \"  Drive $drive is not accessible, skipping\"",
                    "            continue",
                    "        fi",
                    "        ",
                    "        # Check if drive has any mounted partitions",
                    "        if lsblk \"$drive\" -o MOUNTPOINT | grep -v '^$' | grep -q '/'; then",
                    "            log_info \"  Drive $drive has mounted partitions, skipping\"",
                    "            continue",
                    "        fi",
                    "        ",
                    "        # Check if drive is part of existing LVM",
                    "        if pvdisplay \"$drive\"* &>/dev/null; then",
                    "            log_info \"  Drive $drive is part of existing LVM, skipping\"",
                    "            continue",
                    "        fi",
                    "        ",
                    "        # Check if drive is part of existing RAID",
                    "        if grep -q \"$(basename \"$drive\")\" /proc/mdstat 2>/dev/null; then",
                    "            log_info \"  Drive $drive is part of existing RAID, skipping\"",
                    "            continue",
                    "        fi",
                    "        ",
                    "        # Check for filesystem signatures",
                    "        local fs_type",
                    "        fs_type=$(blkid -o value -s TYPE \"$drive\" 2>/dev/null || echo \"\")",
                    "        if [[ -n \"$fs_type\" ]]; then",
                    "            log_info \"  Drive $drive has filesystem signature ($fs_type), skipping\"",
                    "            continue",
                    "        fi",
                    "        ",
                    "        # Drive is available for use",
                    "        log_success \"  Drive $drive is available for RAID5\"",
                    "        UNUSED_DRIVES+=(\"$drive\")",
                    "    done",
                    "    ",
                    "    log_info \"Found ${#UNUSED_DRIVES[@]} unused drives for RAID5: ${UNUSED_DRIVES[*]}\"",
                    "}",
                    "",
                    "# Function to configure RAID5 (only for 3+ drives as requested)",
                    "configure_raid5() {",
                    "    local drive_count=${#UNUSED_DRIVES[@]}",
                    "    ",
                    "    if [[ $drive_count -lt 3 ]]; then",
                    "        log_info \"Found $drive_count unused drives - RAID5 requires 3+ drives, skipping RAID configuration\"",
                    "        send_notification \"RAID5 skipped: Only $drive_count unused drives found (need 3+)\"",
                    "        return 0",
                    "    fi",
                    "    ",
                    "    log_info \"Setting up RAID5 array with $drive_count drives...\"",
                    "    send_notification \"Creating RAID5 array with $drive_count drives: ${UNUSED_DRIVES[*]}\"",
                    "    ",
                    "    # Wipe existing signatures",
                    "    for drive in \"${UNUSED_DRIVES[@]}\"; do",
                    "        log_info \"Wiping drive: $drive\"",
                    "        wipefs -a \"$drive\" || log_warning \"Could not wipe $drive\"",
                    "    done",
                    "    ",
                    "    # Create RAID5 array",
                    "    if mdadm --create /dev/md0 --level=5 --raid-devices=${#UNUSED_DRIVES[@]} \"${UNUSED_DRIVES[@]}\" --verbose; then",
                    "        log_success \"RAID5 array created successfully\"",
                    "        ",
                    "        # Save configuration",
                    "        mdadm --detail --scan >> /etc/mdadm.conf",
                    "        ",
                    "        # Wait for array to be ready",
                    "        log_info \"Waiting for RAID array to initialize...\"",
                    "        sleep 10",
                    "        ",
                    "        # Create LVM on RAID array",
                    "        if pvcreate /dev/md0 && vgcreate data /dev/md0; then",
                    "            log_success \"LVM volume group 'data' created on RAID5\"",
                    "            ",
                    "            # Create logical volumes for different workloads",
                    "            create_workload_volumes",
                    "            ",
                    "            send_notification \"RAID5 storage configuration completed successfully\"",
                    "            return 0",
                    "        else",
                    "            log_error \"Failed to create LVM on RAID5\"",
                    "            send_notification \"ERROR: Failed to create LVM on RAID5 array\"",
                    "            return 1",
                    "        fi",
                    "    else",
                    "        log_error \"Failed to create RAID5 array\"",
                    "        send_notification \"ERROR: Failed to create RAID5 array\"",
                    "        return 1",
                    "    fi",
                    "}",
                    "",
                    "# Function to create workload-specific logical volumes",
                    "create_workload_volumes() {",
                    "    log_info \"Creating logical volumes for workloads...\"",
                    "    ",
                    "    if ! vgdisplay data &>/dev/null; then",
                    "        log_warning \"No 'data' volume group found, skipping volume creation\"",
                    "        return 0",
                    "    fi",
                    "    ",
                    "    # Get available space",
                    "    local data_free_gb",
                    "    local vgs_output",
                    "    if vgs_output=$(vgs data --noheadings --units g --options vg_free 2>/dev/null); then",
                    "        data_free_gb=$(echo \"$vgs_output\" | sed 's/[^0-9.]//g' | cut -d. -f1)",
                    "        log_info \"Available space: ${data_free_gb}GB\"",
                    "    else",
                    "        log_error \"Could not determine available space\"",
                    "        return 1",
                    "    fi",
                    "    ",
                    "    if [[ -z \"$data_free_gb\" ]] || (( data_free_gb < 50 )); then",
                    "        log_warning \"Insufficient space for volume creation: ${data_free_gb}GB\"",
                    "        return 0",
                    "    fi",
                    "    ",
                    "    # Calculate sizes (leaving 5% free space)",
                    "    local usable_space=$((data_free_gb * 95 / 100))",
                    "    local vm_size=$((usable_space * 40 / 100))",
                    "    local container_size=$((usable_space * 30 / 100))",
                    "    local storage_size=$((usable_space * 25 / 100))",
                    "    ",
                    "    log_info \"Creating volumes: VM=${vm_size}G, Container=${container_size}G, Storage=${storage_size}G\"",
                    "    ",
                    "    # Create logical volumes",
                    "    if lvcreate -L \"${vm_size}G\" -n lvvms data && \\",
                    "       lvcreate -L \"${container_size}G\" -n lvcontainers data && \\",
                    "       lvcreate -L \"${storage_size}G\" -n lvstorage data; then",
                    "        ",
                    "        log_success \"Logical volumes created successfully\"",
                    "        ",
                    "        # Create mount points",
                    "        mkdir -p /var/lib/libvirt /var/lib/containers /storage",
                    "        ",
                    "        # Create filesystems",
                    "        log_info \"Creating XFS filesystems...\"",
                    "        if mkfs.xfs /dev/data/lvvms && \\",
                    "           mkfs.xfs /dev/data/lvcontainers && \\",
                    "           mkfs.xfs /dev/data/lvstorage; then",
                    "            ",
                    "            log_success \"Filesystems created successfully\"",
                    "            ",
                    "            # Add to fstab",
                    "            {",
                    "                echo \"/dev/data/lvvms /var/lib/libvirt xfs defaults 0 2\"",
                    "                echo \"/dev/data/lvcontainers /var/lib/containers xfs defaults 0 2\"",
                    "                echo \"/dev/data/lvstorage /storage xfs defaults 0 2\"",
                    "            } >> /etc/fstab",
                    "            ",
                    "            # Mount filesystems",
                    "            if mount -a; then",
                    "                log_success \"All filesystems mounted successfully\"",
                    "                ",
                    "                # Set proper ownership and permissions",
                    "                chown -R qemu:qemu /var/lib/libvirt 2>/dev/null || true",
                    "                chmod 755 /var/lib/libvirt /var/lib/containers /storage",
                    "                ",
                    "                # Restart services to recognize new storage",
                    "                log_info \"Restarting services to recognize new storage...\"",
                    "                systemctl restart cockpit.socket || true",
                    "                systemctl restart libvirtd || true",
                    "                systemctl restart podman || true",
                    "                ",
                    "                log_success \"Storage volumes configured and services restarted\"",
                    "                return 0",
                    "            else",
                    "                log_error \"Failed to mount filesystems\"",
                    "                return 1",
                    "            fi",
                    "        else",
                    "            log_error \"Failed to create filesystems\"",
                    "            return 1",
                    "        fi",
                    "    else",
                    "        log_error \"Failed to create logical volumes\"",
                    "        return 1",
                    "    fi",
                    "}",
                    "",
                    "# Function to display final configuration",
                    "display_storage_summary() {",
                    "    log_success \"=== STORAGE CONFIGURATION SUMMARY ===\"",
                    "    ",
                    "    echo \"Volume Groups:\"",
                    "    vgdisplay | grep -E \"VG Name|VG Size\" || true",
                    "    ",
                    "    echo \"RAID Arrays:\"",
                    "    if [[ -e /proc/mdstat ]]; then",
                    "        cat /proc/mdstat",
                    "    else",
                    "        echo \"No RAID arrays configured\"",
                    "    fi",
                    "    ",
                    "    echo \"Mounted Filesystems:\"",
                    "    df -h | grep -E \"(rocky|data|/storage)\" || echo \"No custom storage mounted\"",
                    "    ",
                    "    echo \"Block Device Layout:\"",
                    "    lsblk",
                    "}",
                    "",
                    "# Error handling with non-critical approach",
                    "handle_error() {",
                    "    local exit_code=$?",
                    "    log_warning \"Storage configuration encountered an error (exit code: $exit_code)\"",
                    "    log_warning \"This is non-critical - deployment will continue\"",
                    "    send_notification \"WARNING: Storage configuration had issues but deployment continues\"",
                    "    # Don't exit - let deployment continue",
                    "    return 0",
                    "}",
                    "",
                    "# Set trap for non-critical error handling",
                    "trap handle_error ERR",
                    "",
                    "# Main execution",
                    "log_info \"=== STARTING STORAGE CONFIGURATION ===\"",
                    "",
                    "# Step 1: Extend boot drive to use all available space",
                    "if detect_boot_drive; then",
                    "    extend_boot_drive",
                    "else",
                    "    log_warning \"Could not detect boot drive for extension\"",
                    "fi",
                    "",
                    "# Step 2: Configure RAID5 for unused drives (3+ drives only)",
                    "detect_unused_drives",
                    "configure_raid5",
                    "",
                    "# Step 3: Display final configuration",
                    "display_storage_summary",
                    "",
                    "# Create completion marker",
                    "touch /tmp/phase-storage-config-complete",
                    "log_success \"Storage configuration phase completed\"",
                    "send_notification \"Storage configuration completed successfully - Boot drive extended and RAID5 configured\"",
                    "",
                    "echo \"Storage configuration completed at: $(date)\""
                ]
            }
        }
    ]
}